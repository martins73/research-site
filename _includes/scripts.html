<script>
  /**
   * Main application JavaScript
   *
   * Handles mobile navigation scroll behavior, profile interactions, modals,
   * dark mode, and liturgical calendar display.
   */
  document.addEventListener("DOMContentLoaded", function () {

    /* ============================================================================
       0. MOBILE: SCROLL FROM SIDEBAR TO CONTENT
       ============================================================================

       On mobile devices (â‰¤768px), when user clicks a sidebar link:
       - If sidebar is visible at top of screen: smooth scroll to main content (shows animation)
       - If sidebar is scrolled past screen: instant scroll to main content (no animation)

       This provides visual feedback about where the content is while avoiding
       animation when the user is already reading further down the page.

       Note: MOBILE_BREAKPOINT_PX is defined in head.html for consistency
    */
    const isMobile = window.matchMedia(`(max-width: ${window.MOBILE_BREAKPOINT_PX}px)`).matches;

    if (isMobile) {
      const sidebar = document.querySelector(".sidebar");

      document.querySelectorAll(".sidebar .sidebar-nav").forEach(link => {
        link.addEventListener("click", () => {
          // Store whether sidebar was visible at time of click
          const sidebarTop = sidebar.getBoundingClientRect().top;
          const wasScrolledDown = sidebarTop < 0 || sidebarTop > 100;

          sessionStorage.setItem("autoScrollToContent", "1");
          sessionStorage.setItem("wasScrolledDown", wasScrolledDown ? "1" : "0");
        });
      });

      const shouldAutoScroll = sessionStorage.getItem("autoScrollToContent") === "1";

      if (shouldAutoScroll) {
        sessionStorage.removeItem("autoScrollToContent");
        const wasScrolledDown = sessionStorage.getItem("wasScrolledDown") === "1";
        sessionStorage.removeItem("wasScrolledDown");

        const main = document.getElementById("main-content");
        if (main) {
          const y = main.getBoundingClientRect().top + window.scrollY - 20;

          // If user was at top when they clicked, use smooth scroll to show animation
          // If user was scrolled down when they clicked, use instant scroll
          window.scrollTo({
            top: y,
            behavior: wasScrolledDown ? "auto" : "smooth"
          });
        }
      }
    }

    /* ============================================================================
       1. SPINNING PROFILE PICTURE
       ============================================================================

       Clicking the profile picture triggers a 3.2 second spinning animation.
       Uses CSS animation defined in style.css with the "spin-effect" class.
    */
    const profilePic = document.querySelector(".js-spin-trigger");
    if (profilePic) {
      const SPIN_DURATION = 3200;
      profilePic.addEventListener("click", function () {
        profilePic.classList.add("spin-effect");
        setTimeout(() => {
          profilePic.classList.remove("spin-effect");
        }, SPIN_DURATION);
      });
    }

    /* ============================================================================
       2. FAMILY DYNAMIC MODAL WITH ACCESSIBILITY
       ============================================================================

       Interactive modal for displaying family member photos and information.

       Features:
       - Click/Enter/Space to open modal with family member photo
       - Click outside modal or Escape key to close
       - Tab navigation loops within modal (focus trap)
       - Full ARIA labels and keyboard support for accessibility
       - Focus returns to triggering element after closing
    */
    const modal = document.getElementById("family-modal");
    const modalImg = document.getElementById("modal-img");
    const modalCaption = document.getElementById("modal-caption");
    const closeButton = document.getElementById("modal-close");
    const triggers = document.querySelectorAll(".family-link");

    const familyData = {{ site.data.easter_eggs.family | jsonify }};

    if (modal && triggers.length > 0 && familyData) {
      let lastFocusedElement = null;

      const openModal = (personKey) => {
        const personData = familyData[personKey];
        if (!personData) return;

        lastFocusedElement = document.activeElement;

        modalImg.src = personData.img;
        modalImg.alt = personData.text;
        modalCaption.innerText = personData.text;

        modal.style.display = "flex";
        modal.setAttribute("aria-hidden", "false");

        if (closeButton) closeButton.focus();

        document.body.style.overflow = "hidden";
      };

      const closeModal = () => {
        modal.style.display = "none";
        modal.setAttribute("aria-hidden", "true");

        document.body.style.overflow = "";

        modalImg.src = "";
        modalImg.alt = "";
        modalCaption.innerText = "";

        if (lastFocusedElement) lastFocusedElement.focus();
      };

      triggers.forEach((trigger) => {
        trigger.setAttribute("role", "button");
        trigger.setAttribute("tabindex", "0");
        trigger.setAttribute("aria-haspopup", "dialog");

        trigger.addEventListener("click", function (e) {
          e.preventDefault();
          const personKey = this.getAttribute("data-person");
          openModal(personKey);
        });

        trigger.addEventListener("keydown", function (e) {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            const personKey = this.getAttribute("data-person");
            openModal(personKey);
          }
        });
      });

      if (closeButton) closeButton.addEventListener("click", closeModal);

      modal.addEventListener("click", function (e) {
        if (e.target === modal) closeModal();
      });

      document.addEventListener("keydown", function (e) {
        if (e.key === "Escape" && modal.style.display === "flex") {
          closeModal();
        }
      });

      modal.addEventListener("keydown", function (e) {
        if (e.key === "Tab") {
          const focusableElements = modal.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
          );

          if (focusableElements.length === 0) return;

          const firstElement = focusableElements[0];
          const lastElement = focusableElements[focusableElements.length - 1];

          if (e.shiftKey) {
            if (document.activeElement === firstElement) {
              e.preventDefault();
              lastElement.focus();
            }
          } else {
            if (document.activeElement === lastElement) {
              e.preventDefault();
              firstElement.focus();
            }
          }
        }
      });
    }

    /* ============================================================================
       3. DARK MODE TOGGLE
       ============================================================================

       Toggle button to switch between light and dark themes.

       - Theme preference persisted in localStorage
       - Initial theme applied in head.html before page renders (prevents flash)
       - Accessible via keyboard and screen readers
    */
    const themeToggle = document.getElementById("theme-toggle");
    if (themeToggle) {
      const getCurrentTheme = () => {
        return document.documentElement.getAttribute("data-theme") || "light";
      };

      const updateThemeLabels = (theme) => {
        const isDark = theme === "dark";
        themeToggle.setAttribute("aria-label", isDark ? "Switch to light mode" : "Switch to dark mode");
        themeToggle.setAttribute("title", isDark ? "Switch to light mode" : "Switch to dark mode");
      };

      const setTheme = (theme) => {
        document.documentElement.setAttribute("data-theme", theme);
        localStorage.setItem("theme", theme);
        updateThemeLabels(theme);
      };

      // Set initial theme labels (theme itself is set in head.html)
      updateThemeLabels(getCurrentTheme());

      // Toggle theme on button click
      themeToggle.addEventListener("click", () => {
        const currentTheme = getCurrentTheme();
        const newTheme = currentTheme === "dark" ? "light" : "dark";
        setTheme(newTheme);
      });
    }

    /* ============================================================================
       4. SAINT OF THE DAY (FOOTER HOVER)
       ============================================================================

       Displays the liturgical calendar's saint of the day in the footer.

       Behavior:
       - Hover over the cross (âœ) symbol to display saint information
       - Intelligently formats saint names (singular/plural, strips prefix)
       - Falls back to copyright text if no saint is available
    */
    
    const trigger = document.getElementById("saint-trigger");
    const target = document.getElementById("copyright-content");
    
    if (trigger && target) {
      const today = new Date();
      const key = (today.getMonth() + 1) + "-" + today.getDate();
    
      // Retrieve saint data
      const saintsByDay = {{ site.data.easter_eggs.saints | jsonify }};
      const saints = saintsByDay ? saintsByDay[key] : null;
    
      // Capture original state
      const originalHTML = target.innerHTML;
      const originalText = target.innerText;
    
      // Format Helper
      const formatSaintList = (arr) => {
        if (!arr || arr.length === 0) return "";
        if (arr.length === 1) return arr[0];
        const cleaned = arr.map((s) => (s || "").trim()).filter(Boolean);
        const stripPrefix = (s, rx) => s.replace(rx, "").trim();
        
        if (cleaned.every((s) => /^Saint\s+/i.test(s))) {
          return "Saints " + cleaned.map((s) => stripPrefix(s, /^Saint\s+/i)).join(" and ");
        }
        if (cleaned.every((s) => /^Blessed\s+/i.test(s))) {
          return "Blesseds " + cleaned.map((s) => stripPrefix(s, /^Blessed\s+/i)).join(" and ");
        }
        return cleaned.join(" and ");
      };
    
      if (saints && saints.length > 0) {
        const saintText = formatSaintList(saints);
    
        // --- Action: Show ---
        const showSaint = () => {
          target.style.transition = "opacity 0.2s";
          target.style.opacity = "0";
          setTimeout(() => {
            target.innerText = "Feast of " + saintText;
            target.style.color = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
            target.style.fontWeight = "500";
            target.style.opacity = "1";
          }, 200);
        };
    
        // --- Action: Hide ---
        const hideSaint = () => {
          target.style.transition = "opacity 0.2s";
          target.style.opacity = "0";
          setTimeout(() => {
            if (originalHTML !== originalText) {
              target.innerHTML = originalHTML;
            } else {
              target.innerText = originalText;
            }
            target.style.color = "inherit";
            target.style.fontWeight = "normal";
            target.style.opacity = "1";
          }, 200);
        };
    
        // --- DESKTOP (Hover) ---
        trigger.addEventListener("mouseenter", showSaint);
        trigger.addEventListener("mouseleave", hideSaint);
    
        // --- MOBILE (Hold + Delay) ---
        // 1. Touch Starts: Show immediately
        trigger.addEventListener("touchstart", (e) => {
             // Prevent default only if cancelable to stop 'sticky' clicks
             if(e.cancelable) e.preventDefault(); 
             showSaint(); 
        }, { passive: false });
        
        // 2. Touch Ends: Wait 0.5s (500ms) before hiding
        trigger.addEventListener("touchend", () => {
            setTimeout(hideSaint, 500); // <--- THE DELAY IS HERE
        });
    
        trigger.addEventListener("touchcancel", () => {
            setTimeout(hideSaint, 500);
        });
      }
    }

    /* ============================================================================
       5. MOBILE: SCROLL TO TOP ON REFRESH
       ============================================================================

       On mobile, refreshing the page (e.g. tapping Go in the address bar) restores
       scroll position by default. This overrides that to always start at the top.
    */
    if (window.matchMedia(`(max-width: ${window.MOBILE_BREAKPOINT_PX}px)`).matches) {
      if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
      }
      window.scrollTo(0, 0);
    }

    /* ============================================================================
       6. CARBON BADGE (WEBSITE CARBON API)
       ============================================================================ */
    (function() {
      const badgeContainer = document.getElementById('wcb');
      if (!badgeContainer) return;

      const SITE_URL = '{{ site.url }}';
      const domainSlug = SITE_URL
        .replace(/^https?:\/\//, '')
        .replace(/\/$/, '')
        .replace(/\./g, '-');

      const reportUrl = `https://www.websitecarbon.com/website/${domainSlug}/`;
      const apiUrl = 'https://api.websitecarbon.com/b?url=' + encodeURIComponent(SITE_URL + '/');

      const FALLBACK = { c: '0.05', p: '92' };

      function renderBadge(data) {
        if (!data || data.c === undefined) {
          data = FALLBACK;
        }

        badgeContainer.innerHTML = `
          <span class="wcb-text">
            ${data.c}g of CO<sub>2</sub>/view<br>
            Cleaner than ${data.p}% of pages
            <a class="wcb-link" target="_blank" rel="noopener" href="${reportUrl}">tested</a>.
          </span>
        `;
      }

      const cacheKey = 'wcb_' + domainSlug;
      const cached = localStorage.getItem(cacheKey);
      const now = new Date().getTime();

      if (cached) {
        try {
          const r = JSON.parse(cached);
          if (now - r.t < 86400000) {
            renderBadge(r.d);
            return;
          }
        } catch (e) {
          localStorage.removeItem(cacheKey);
        }
      }

      fetch(apiUrl)
        .then(response => {
          if (!response.ok) throw new Error('Network status: ' + response.status);
          return response.json();
        })
        .then(data => {
          renderBadge(data);
          localStorage.setItem(cacheKey, JSON.stringify({ t: now, d: data }));
        })
        .catch(err => {
          console.error('Carbon Badge Error:', err);
          renderBadge(FALLBACK);
        });
    })();

    console.log(
      "%cðŸ‘‹ Hi, I'm {{ site.author.given_name }}.\n%cInterested in my code? Check out the repo: {{ site.social.github }}",
      "color: #2774AE; font-size: 20px; font-weight: bold; font-family: sans-serif;",
      "color: #64748b; font-size: 12px; font-family: sans-serif;"
    );
  });

  /* ============================================================================
     7. RESEARCH PAPERS: TOGGLE ABSTRACT (Global scope for onclick attributes)
     ============================================================================

     Expands/collapses research paper abstracts when user clicks the toggle button.
     Updates button text and ARIA attributes for accessibility.
  */
  function toggleAbstract(index, e) {
    const abstractElement = document.getElementById(`abstract-${index}`);
    const button = e.target;

    if (abstractElement.classList.contains('collapsed')) {
      abstractElement.classList.remove('collapsed');
      abstractElement.classList.add('expanded');
      button.textContent = 'Hide Abstract';
      button.setAttribute('aria-expanded', 'true');
    } else {
      abstractElement.classList.remove('expanded');
      abstractElement.classList.add('collapsed');
      button.textContent = 'Show Abstract';
      button.setAttribute('aria-expanded', 'false');
    }
  }
</script>
