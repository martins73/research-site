<script>
  const SITE_CONFIG = window.__SITE_CONFIG || {};
  const SERVICE_WORKER_URL = SITE_CONFIG.serviceWorker || {{ site.service_worker | default: '/sw.js' | relative_url | jsonify }};

  /**
   * Main application JavaScript
   *
   * Handles mobile navigation scroll behavior, profile interactions, modals,
   * dark mode, and liturgical calendar display.
   */
  document.addEventListener("DOMContentLoaded", function () {

    /* ============================================================================
       CONFIGURATION BRIDGE
       ============================================================================
       Injects Jekyll data from _config.yml into a JavaScript object.
       This separates data from logic, preventing hardcoded values in the script.
    */
    const CONFIG = {
      // Logic & Paths
      mobileBreakpoint: SITE_CONFIG.mobileBreakpoint || {{ site.mobile_breakpoint | default: 768 }},
      spinDuration: {{ site.spin_duration | default: 3200 }},
      
      // Data
      authorName: {{ site.author.given_name | jsonify }},
      repoUrl: {{ site.social.github | jsonify }},
      themeColor: {{ site.data.theme.themes[site.color_theme].light.accent | default: '#2774AE' | jsonify }},
      
      // Text & Data Labels (from _config.yml)
      text: {
        darkMode: {
          toLight: {{ site.ui_text.dark_mode.to_light | default: 'Switch to light mode' | jsonify }},
          toDark: {{ site.ui_text.dark_mode.to_dark | default: 'Switch to dark mode' | jsonify }}
        },
        saints: {
          feast: {{ site.ui_text.saints.feast_prefix | default: 'Feast of ' | jsonify }},
          and: {{ site.ui_text.saints.conjunction | default: ' and ' | jsonify }}
        },
        carbon: {
          grams: {{ site.ui_text.carbon.grams | default: 'g of CO<sub>2</sub>/view' | jsonify }},
          cleaner: {{ site.ui_text.carbon.cleaner | default: 'Cleaner than' | jsonify }},
          percent: {{ site.ui_text.carbon.percent | default: '% of pages' | jsonify }},
          tested: {{ site.ui_text.carbon.tested | default: 'tested' | jsonify }},
          // Fallback Data
          fallbackC: {{ site.ui_text.carbon.fallback_grams | default: '0.03' | jsonify }},
          fallbackP: {{ site.ui_text.carbon.fallback_percent | default: '94' | jsonify }}
        },
        research: {
          show: {{ site.ui_text.research.show_abstract | default: 'Show Abstract' | jsonify }},
          hide: {{ site.ui_text.research.hide_abstract | default: 'Hide Abstract' | jsonify }}
        },
        console: {
          greeting: {{ site.ui_text.console.greeting | default: "ðŸ‘‹ Hi, I'm" | jsonify }},
          repo: {{ site.ui_text.console.repo | default: 'Check out the repo:' | jsonify }}
        }
      }
    };

    /* ============================================================================
       0. MOBILE: SCROLL FROM SIDEBAR TO CONTENT
       ============================================================================

       On mobile devices, when user clicks a sidebar link:
       - If sidebar is visible at top of screen: smooth scroll to main content (shows animation)
       - If sidebar is scrolled past screen: instant scroll to main content (no animation)

       This provides visual feedback about where the content is while avoiding
       animation when the user is already reading further down the page.
    */
    const isMobile = window.matchMedia(`(max-width: ${CONFIG.mobileBreakpoint}px)`).matches;
    let didAutoScrollToContent = false;  // Track if we auto-scrolled this page load

    if (isMobile) {
      const sidebar = document.querySelector(".sidebar");

      // Track sidebar visibility without forcing layout on click.
      // IntersectionObserver updates this flag asynchronously so the
      // click handler can read a pre-cached value instead of calling
      // getBoundingClientRect() which forces a synchronous layout.
      let sidebarIsScrolledDown = false;
      if (sidebar) {
        const sidebarObserver = new IntersectionObserver(
          (entries) => { sidebarIsScrolledDown = !entries[0].isIntersecting; },
          { threshold: 0.5 }
        );
        sidebarObserver.observe(sidebar);
      }

      document.querySelectorAll(".sidebar .sidebar-nav").forEach(link => {
        link.addEventListener("click", () => {
          sessionStorage.setItem("autoScrollToContent", "1");
          sessionStorage.setItem("wasScrolledDown", sidebarIsScrolledDown ? "1" : "0");
        });
      });

      const shouldAutoScroll = sessionStorage.getItem("autoScrollToContent") === "1";

      if (shouldAutoScroll) {
        sessionStorage.removeItem("autoScrollToContent");
        const wasScrolledDown = sessionStorage.getItem("wasScrolledDown") === "1";
        sessionStorage.removeItem("wasScrolledDown");

        const main = document.getElementById("main-content");
        if (main) {
          didAutoScrollToContent = true;  // Mark that we're doing auto-scroll

          // Use requestAnimationFrame to ensure layout is complete before scrolling
          requestAnimationFrame(() => {
            const y = main.getBoundingClientRect().top + window.scrollY - 20;

            // If user was at top when they clicked, use smooth scroll to show animation
            // If user was scrolled down when they clicked, use instant scroll
            window.scrollTo({
              top: y,
              behavior: wasScrolledDown ? "auto" : "smooth"
            });
          });
        }
      }
    }

    /* ============================================================================
       1. SPINNING PROFILE PICTURE
       ============================================================================

       Clicking the profile picture triggers a spinning animation.
       Duration is configured in _config.yml (default 3.2s).
    */
    const profilePic = document.querySelector(".js-spin-trigger");
    if (profilePic) {
      const triggerSpin = () => {
        // Force the CSS duration to match the Config (milliseconds -> seconds)
        profilePic.style.animationDuration = (CONFIG.spinDuration / 1000) + 's';

        profilePic.classList.add("spin-effect");

        // Remove class after the exact duration from config
        setTimeout(() => {
          profilePic.classList.remove("spin-effect");
          profilePic.style.animationDuration = ''; // Clean up
        }, CONFIG.spinDuration);
      };

      profilePic.addEventListener("click", triggerSpin);
      profilePic.addEventListener("keydown", function (e) {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          triggerSpin();
        }
      });
    }

    /* ============================================================================
       2. FAMILY DYNAMIC MODAL WITH ACCESSIBILITY
       ============================================================================

       Interactive modal for displaying family member photos and information.

       Features:
       - Click/Enter/Space to open modal with family member photo
       - Click outside modal or Escape key to close
       - Tab navigation loops within modal (focus trap)
       - Full ARIA labels and keyboard support for accessibility
       - Focus returns to triggering element after closing
    */
    const modal = document.getElementById("family-modal");
    const modalImg = document.getElementById("modal-img");
    const modalCaption = document.getElementById("modal-caption");
    const closeButton = document.getElementById("modal-close");
    const triggers = document.querySelectorAll(".family-link");
    const familyData = {{ site.data.easter_eggs.family | jsonify }};

    if (modal && triggers.length > 0 && familyData) {
      let lastFocusedElement = null;

      const openModal = (personKey) => {
        const personData = familyData[personKey];
        if (!personData) return;

        lastFocusedElement = document.activeElement;

        modalImg.src = personData.img + '?v={{ site.time | date: "%s" }}';
        modalImg.alt = personData.text;
        modalCaption.innerText = personData.text;

        modal.style.display = "flex";
        modal.setAttribute("aria-hidden", "false");

        if (closeButton) closeButton.focus();

        document.body.style.overflow = "hidden";
      };

      const closeModal = () => {
        modal.style.display = "none";
        modal.setAttribute("aria-hidden", "true");

        document.body.style.overflow = "";

        modalImg.src = "";
        modalImg.alt = "";
        modalCaption.innerText = "";

        if (lastFocusedElement) lastFocusedElement.focus();
      };

      triggers.forEach((trigger) => {
        trigger.setAttribute("role", "button");
        trigger.setAttribute("tabindex", "0");
        trigger.setAttribute("aria-haspopup", "dialog");

        trigger.addEventListener("click", function (e) {
          e.preventDefault();
          openModal(this.getAttribute("data-person"));
        });

        trigger.addEventListener("keydown", function (e) {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            openModal(this.getAttribute("data-person"));
          }
        });
      });

      if (closeButton) closeButton.addEventListener("click", closeModal);

      modal.addEventListener("click", function (e) {
        if (e.target === modal) closeModal();
      });

      document.addEventListener("keydown", function (e) {
        if (e.key === "Escape" && modal.style.display === "flex") {
          closeModal();
        }
      });

      // Focus Trap
      modal.addEventListener("keydown", function (e) {
        if (e.key === "Tab") {
          const focusableElements = modal.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
          );

          if (focusableElements.length === 0) return;

          const firstElement = focusableElements[0];
          const lastElement = focusableElements[focusableElements.length - 1];

          if (e.shiftKey) {
            if (document.activeElement === firstElement) {
              e.preventDefault();
              lastElement.focus();
            }
          } else {
            if (document.activeElement === lastElement) {
              e.preventDefault();
              firstElement.focus();
            }
          }
        }
      });
    }

    /* ============================================================================
       3. DARK MODE TOGGLE
       ============================================================================

       Toggle button to switch between light and dark themes.

       - Theme preference persisted in localStorage
       - Initial theme applied in head.html before page renders (prevents flash)
       - Accessible via keyboard and screen readers
    */
    const themeToggle = document.getElementById("theme-toggle");
    if (themeToggle) {
      const getCurrentTheme = () => {
        return document.documentElement.getAttribute("data-theme") || "light";
      };

      const updateThemeLabels = (theme) => {
        const isDark = theme === "dark";
        const label = isDark ? CONFIG.text.darkMode.toLight : CONFIG.text.darkMode.toDark;
        themeToggle.setAttribute("aria-label", label);
        themeToggle.setAttribute("title", label);
      };

      const setTheme = (theme) => {
        document.documentElement.setAttribute("data-theme", theme);
        localStorage.setItem("theme", theme);
        updateThemeLabels(theme);
      };

      // Set initial theme labels (theme itself is set in head.html)
      updateThemeLabels(getCurrentTheme());

      // Toggle theme on button click
      themeToggle.addEventListener("click", () => {
        const currentTheme = getCurrentTheme();
        const newTheme = currentTheme === "dark" ? "light" : "dark";
        setTheme(newTheme);
      });
    }

    /* ============================================================================
       4. SAINT OF THE DAY (FOOTER HOVER)
       ============================================================================

       Displays the liturgical calendar's saint of the day in the footer.

       Behavior:
       - Hover over the cross (âœ) symbol to display saint information
       - Intelligently formats saint names (singular/plural, strips prefix)
       - Falls back to copyright text if no saint is available
    */
    const trigger = document.getElementById("saint-trigger");
    const target = document.getElementById("copyright-content");
    
    if (trigger && target) {
      const today = new Date();
      const key = (today.getMonth() + 1) + "-" + today.getDate();
      
      // Retrieve saint data
      const saintsByDay = {{ site.data.easter_eggs.saints | jsonify }};
      const saints = saintsByDay ? saintsByDay[key] : null;
      
      // Capture original state
      const originalHTML = target.innerHTML;
      const originalText = target.innerText;
      
      // Format Helper
      const formatSaintList = (arr) => {
        if (!arr || arr.length === 0) return "";
        if (arr.length === 1) return arr[0];
        const cleaned = arr.map((s) => (s || "").trim()).filter(Boolean);
        const stripPrefix = (s, rx) => s.replace(rx, "").trim();
        
        if (cleaned.every((s) => /^Saint\s+/i.test(s))) {
          return "Saints " + cleaned.map((s) => stripPrefix(s, /^Saint\s+/i)).join(CONFIG.text.saints.and);
        }
        if (cleaned.every((s) => /^Blessed\s+/i.test(s))) {
          return "Blesseds " + cleaned.map((s) => stripPrefix(s, /^Blessed\s+/i)).join(CONFIG.text.saints.and);
        }
        return cleaned.join(CONFIG.text.saints.and);
      };
      
      if (saints && saints.length > 0) {
        const saintText = formatSaintList(saints);
        
        // --- Action: Show ---
        const showSaint = () => {
          target.style.transition = "opacity 0.2s";
          target.style.opacity = "0";
          setTimeout(() => {
            target.innerText = CONFIG.text.saints.feast + saintText;
            target.style.color = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
            target.style.fontWeight = "500";
            target.style.opacity = "1";
          }, 200);
        };
        
        // --- Action: Hide ---
        const hideSaint = () => {
          target.style.transition = "opacity 0.2s";
          target.style.opacity = "0";
          setTimeout(() => {
            if (originalHTML !== originalText) {
              target.innerHTML = originalHTML;
            } else {
              target.innerText = originalText;
            }
            target.style.color = "inherit";
            target.style.fontWeight = "normal";
            target.style.opacity = "1";
          }, 200);
        };
        
        // --- DESKTOP (Hover) ---
        trigger.addEventListener("mouseenter", showSaint);
        trigger.addEventListener("mouseleave", hideSaint);
        
        // --- MOBILE (Hold + Delay) ---
        // 1. Touch Starts: Show immediately
        trigger.addEventListener("touchstart", (e) => {
             // Prevent default only if cancelable to stop 'sticky' clicks
             if(e.cancelable) e.preventDefault(); 
             showSaint(); 
        }, { passive: false });
        
        // 2. Touch Ends: Wait before hiding
        trigger.addEventListener("touchend", () => {
            setTimeout(hideSaint, 800); 
        });
        
        trigger.addEventListener("touchcancel", () => {
            setTimeout(hideSaint, 800);
        });
      }
    }

    /* ============================================================================
       5. MOBILE: SCROLL TO TOP ON REFRESH
       ============================================================================

       On mobile, refreshing the page (e.g. tapping Go in the address bar) restores
       scroll position by default. This overrides that to always start at the top.

       IMPORTANT: Don't scroll to top if we're auto-scrolling to content from sidebar.
    */
    if (window.matchMedia(`(max-width: ${CONFIG.mobileBreakpoint}px)`).matches) {
      if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
      }
      // Only scroll to top if we're NOT auto-scrolling to content
      if (!didAutoScrollToContent) {
        window.scrollTo(0, 0);
      }
    }

    /* ============================================================================
       6. CARBON BADGE (WEBSITE CARBON API)
       ============================================================================ */
    // Deferred with requestIdleCallback (or setTimeout fallback) so the badge
    // fetch and innerHTML update do not run during early user interactions,
    // which was causing INP regressions (~400ms) on the #wcb element.
    (window.requestIdleCallback || function(cb) { setTimeout(cb, 200); })(function() {
    (function() {
      const badgeContainer = document.getElementById('wcb');
      if (!badgeContainer) return;

      const SITE_URL = '{{ site.url }}';
      const domainSlug = SITE_URL
        .replace(/^https?:\/\//, '')
        .replace(/\/$/, '')
        .replace(/\./g, '-');

      const reportUrl = `https://www.websitecarbon.com/website/${domainSlug}/`;
      const apiUrl = 'https://api.websitecarbon.com/b?url=' + encodeURIComponent(SITE_URL + '/');

      // Uses config values for fallback if API fails
      const FALLBACK = { c: CONFIG.text.carbon.fallbackC, p: CONFIG.text.carbon.fallbackP };

      function renderBadge(data) {
        if (!data || data.c === undefined) {
          data = FALLBACK;
        }

        badgeContainer.innerHTML = `
          <span class="wcb-text">
            ${data.c}${CONFIG.text.carbon.grams}<br>
            ${CONFIG.text.carbon.cleaner} ${data.p}${CONFIG.text.carbon.percent}
            <a class="wcb-link" target="_blank" rel="noopener" href="${reportUrl}">${CONFIG.text.carbon.tested}</a>.
          </span>
        `;
      }

      const cacheKey = 'wcb_' + domainSlug;
      const cached = localStorage.getItem(cacheKey);
      const now = new Date().getTime();

      if (cached) {
        try {
          const r = JSON.parse(cached);
          if (now - r.t < 86400000) {
            renderBadge(r.d);
            return;
          }
        } catch (e) {
          localStorage.removeItem(cacheKey);
        }
      }

      fetch(apiUrl)
        .then(response => {
          if (!response.ok) throw new Error('Network status: ' + response.status);
          return response.json();
        })
        .then(data => {
          renderBadge(data);
          localStorage.setItem(cacheKey, JSON.stringify({ t: now, d: data }));
        })
        .catch(err => {
          console.error('Carbon Badge Error:', err);
          renderBadge(FALLBACK);
        });
    })();
    }); // end requestIdleCallback

    /* ============================================================================
       7. RESEARCH PAPERS: TOGGLE ABSTRACT
       ============================================================================

       Expands/collapses research paper abstracts when user clicks the toggle button.
       {% if site.typewriter_abstract %}
       When enabled, text is revealed letter-by-letter with a blinking cursor.
       Controlled by typewriter_abstract in _config.yml.
       {% endif %}
    */
    (function() {
      {% if site.typewriter_abstract %}
      var TYPEWRITER_SPEED = {{ site.typewriter_speed | default: 12 }};
      var prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      {% endif %}

      // Store original HTML for each abstract (trimmed to remove template whitespace)
      var abstractStore = {};
      document.querySelectorAll('.paper-abstract').forEach(function(el) {
        abstractStore[el.id] = el.innerHTML.trim();
      });

      {% if site.typewriter_abstract %}
      // Track active typewriter timers so we can cancel mid-typing
      var activeTimers = {};

      function cancelTypewriter(id) {
        if (activeTimers[id]) {
          clearTimeout(activeTimers[id]);
          delete activeTimers[id];
        }
      }

      function typewriterReveal(el, id) {
        var originalHTML = abstractStore[id];

        // Parse original HTML to extract paragraph texts (markdownify wraps in <p>)
        var temp = document.createElement('div');
        temp.innerHTML = originalHTML;
        var sourceParagraphs = temp.querySelectorAll('p');
        var paraTexts = [];
        sourceParagraphs.forEach(function(p) {
          var text = p.textContent.trim();
          if (text) paraTexts.push(text);
        });
        // Fallback: if no <p> tags, treat entire content as one block
        if (paraTexts.length === 0) {
          var fallback = (temp.textContent || '').trim();
          if (fallback) paraTexts.push(fallback);
        }

        // Build the typing DOM: one <p> per paragraph, cursor in the first
        el.innerHTML = '';
        var cursor = document.createElement('span');
        cursor.className = 'typewriter-cursor';
        cursor.textContent = '|';

        var currentPara = document.createElement('p');
        el.appendChild(currentPara);
        var textNode = document.createTextNode('');
        currentPara.appendChild(textNode);
        currentPara.appendChild(cursor);

        var paraIndex = 0;
        var charIndex = 0;

        function typeNext() {
          if (paraIndex >= paraTexts.length) {
            // Typing complete: restore original HTML with formatting
            cursor.remove();
            el.innerHTML = originalHTML;
            delete activeTimers[id];
            return;
          }
          var currentText = paraTexts[paraIndex];
          if (charIndex < currentText.length) {
            textNode.textContent += currentText.charAt(charIndex);
            charIndex++;
            activeTimers[id] = setTimeout(typeNext, TYPEWRITER_SPEED);
          } else {
            // Paragraph done â€” move to next
            paraIndex++;
            charIndex = 0;
            if (paraIndex < paraTexts.length) {
              cursor.remove();
              currentPara = document.createElement('p');
              el.appendChild(currentPara);
              textNode = document.createTextNode('');
              currentPara.appendChild(textNode);
              currentPara.appendChild(cursor);
              activeTimers[id] = setTimeout(typeNext, TYPEWRITER_SPEED);
            } else {
              // All paragraphs done
              cursor.remove();
              el.innerHTML = originalHTML;
              delete activeTimers[id];
            }
          }
        }

        typeNext();
      }
      {% endif %}

      document.addEventListener('click', function(e) {
        var button = e.target.closest('[data-abstract]');
        if (!button) return;

        var index = button.getAttribute('data-abstract');
        var abstractElement = document.getElementById('abstract-' + index);
        if (!abstractElement) return;
        var abstractId = abstractElement.id;

        if (abstractElement.classList.contains('collapsed')) {
          // --- EXPAND ---
          {% if site.typewriter_abstract %}cancelTypewriter(abstractId);{% endif %}
          abstractElement.classList.remove('collapsed');
          abstractElement.classList.add('expanded');
          button.textContent = CONFIG.text.research.hide;
          button.setAttribute('aria-expanded', 'true');

          {% if site.typewriter_abstract %}
          if (prefersReducedMotion) {
            abstractElement.innerHTML = abstractStore[abstractId];
          } else {
            typewriterReveal(abstractElement, abstractId);
          }
          {% endif %}
        } else {
          // --- COLLAPSE ---
          {% if site.typewriter_abstract %}cancelTypewriter(abstractId);{% endif %}
          abstractElement.innerHTML = abstractStore[abstractId];
          abstractElement.classList.remove('expanded');
          abstractElement.classList.add('collapsed');
          button.textContent = CONFIG.text.research.show;
          button.setAttribute('aria-expanded', 'false');
        }
      });
    })();

    /* ============================================================================
       8. SCROLL REVEAL â€” BLOCK FADE-IN ON SCROLL
       ============================================================================

       Fades in .scroll-reveal elements as they enter the viewport.
       One-shot: once visible, elements stay visible permanently (unobserved).
       Controlled by scroll_reveal in _config.yml.
    */
    {% if site.scroll_reveal %}
    if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
      document.documentElement.classList.add('sr-enabled');

      var srObserver = new IntersectionObserver(function(entries) {
        entries.forEach(function(entry) {
          if (entry.isIntersecting) {
            entry.target.classList.add('sr-visible');
            srObserver.unobserve(entry.target);
          }
        });
      }, {
        threshold: {{ site.scroll_reveal_threshold | default: 0.15 }},
        rootMargin: '0px 0px {{ site.scroll_reveal_margin | default: "-15%" }} 0px'
      });

      document.querySelectorAll('.scroll-reveal').forEach(function(el) {
        srObserver.observe(el);
      });

      // Guarantee bottom-of-page elements always reveal
      window.addEventListener('scroll', function() {
        if ((window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 2)) {
          document.querySelectorAll('.scroll-reveal:not(.sr-visible)').forEach(function(el) {
            el.classList.add('sr-visible');
            srObserver.unobserve(el);
          });
        }
      }, { passive: true });
    }
    {% endif %}

    console.log(
      `%c${CONFIG.text.console.greeting} ${CONFIG.authorName}.\n%c${CONFIG.text.console.repo} ${CONFIG.repoUrl}`,
      `color: ${CONFIG.themeColor}; font-size: 20px; font-weight: bold; font-family: sans-serif;`,
      "color: #64748b; font-size: 12px; font-family: sans-serif;"
    );

  });

  /* ============================================================================
     9. SERVICE WORKER REGISTRATION
     ============================================================================ */
  if ('serviceWorker' in navigator && SERVICE_WORKER_URL) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register(SERVICE_WORKER_URL).catch(function(error) {
        console.warn('Service worker registration failed:', error);
      });
    });
  }
</script>
